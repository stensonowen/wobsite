title: Wikilinks: A Retrospective (and Prospective)
date: 2017-03-09
description: Parse wikipedia dump data, load and represent it efficiently, compute the pagerank of each article, perform a breadth-first search between any two articles, and serve basic web requests to show everything off.
url: wikilinks.html

---
<h2 id="current-status">Current Status</h2>
<p>Currently the fastest form of the project is a pure Rust rewrite of parsing, storing, searching, computing pageranks, and serving web requests.</p>
<p>The link data is parsed from sql dumps published monthly, with adapting for redirects and dead pages. It is saved to disk and loaded into a hash table where the <a href="https://en.wikipedia.org/wiki/Pagerank">pagerank</a> of each page can be computed and saved. A bidirectional breadth-first search can then be run on the link table, searching the children and grandchildren of the source and the parents and grandparents of the destination until they intersect, a process which completes relatively quickly in the worst case even with an ugly order notation. Searches are cached using <a href="https://www.postgresql.org/">Postgres</a> with <a href="https://diesel.rs">Diesel</a>, and <a href="https://rocket.rs">Rocket</a> processes requests to serve up saved searches or perform new ones.</p>
<p>Overall this makes for a pretty fast website. Storing the table in memory only fills about 6GB. The longest breadth-first search I've been able to run finished in a few seconds. Parsing the sql dumps and computing pageranks take about one and twelve hours respectively, but both can be improved and only need to be run once (or zero times) per month. Table population completes in one minute, and hasn't yet been multithreaded.</p>
<p>Searches are fast and the process seems to scale well, but it can always be better.</p>
<h2 id="original-approach">Original Approach</h2>
<p>Early on, the process of loading links and seeking paths was quite straightforward. It was divided into three real components.</p>
<ol class="incremental" style="list-style-type: decimal">
<li><p>A python script would parse the wikipedia dump's text file, looking for the pattern that would indicate an internal link, (e.g. &quot;... page content with a [[link article title|link friendly name]]...&quot;). The script would produce a text file associating each article title with the titles of all of its children. This was useful because parsing was somewhat expensive; I/O is a bottleneck, so cutting out most of the text that would be ignored anyway is helpful. This process isn't ideally efficient, taking about half an hour on one core for the full English dump, but it only needs to be run once per dump.</p></li>
<li><p>The next step was table generation. To make lookups fast, everything is stored in a pretty minimalistic hash table, mapping a hash of an article title to a struct containing its title and children. So for each parent/child title pair in the python parse data, each string was hashed and looked up (and inserted if necessary) to get its associated index. Then the collection of children at <code>table[parent_index]-&gt;children</code> was updated to include the child index. This way each string only needs to be stored once, and all of the links can be represented as 32-bit integers, which are small and cheap to operate on.</p></li>
<li><p>Performing a breadth-first search from one index to another is just a matter of expanding the pool of reachable indices until it includes the destination index. If <code>dst_index</code> is a child of <code>src_index</code>, then the search is over; otherwise each of <code>src_index</code>'s children is added to a pool of seen indices. For each element in this pool (which is currently a child of <code>src_index</code>), if <code>dst_index</code> is among its children, then the search is over (there might be other equally long searches, but there can't be any shorter ones); otherwise all of its children (which are <code>src_id</code>'s grandchildren) that have not been seen before are added to a new pool of descendants to be searched, repeating until the <code>dst_index</code> is found or a max iteration is reached. This effectively populated sets of indices that are reachable in no more than <code>n</code> iterations for increasing values of <code>n</code>. It is as efficient as expected, only storing what it needs (a set of the <code>n</code>th generation of descendants and a set of all other reachable indices) and not entering into any cycles. This doesn't scale particularly well: articles can have several hundred children (the average is probably around ~80), so that means storing 80<sup>i</sup>; a search of depth 10 could require searching through <i>billions</i> of integers. Fortunately, most searches are much shorter than this, but it meant that searches could have wildly unpredictable run times, from milliseconds to minutes.</p></li>
</ol>
<h3 id="speedmemory-optimizations">Speed/Memory optimizations</h3>
<p>There were a handful of ways I sped this process up over the course of a few months. It initially had almost comically bad resource consumption, requiring an ~80GB pagefile and ~13 hours to load into memory (from the end of the python parsing step to the beginning of the first search), but this improved drastically after heavy refactoring and profiling.</p>
<ul class="incremental">
<li>Refactoring was the first major step; it didn't speed things up per se, but it turned the codebase from a mess of delicate unreadable garbage into something much easier to hack on.</li>
<li>Switching from using a linked list to store children indices to a vector. My initial thought process was that the hash table took up lots of contiguous memory so some non-contiguous memory would lead to better usage of RAM. In reality, it just turned every 32-bit integer into a list node that also contained two 64-bit pointers, and it killed any semblance of cache locality populating/searching could have used. I was fresh out of data structures; can you blame me?</li>
<li>Tweaked python parser to also output the number of children for each article. This allowed the table population step to perfectly allocate storage for every vector of children, leading to fewer reallocations and less unnecessary overhead.</li>
<li>Reduced a layer or two of indirection in the entry struct and hash table. I hadn't given this much consideration while initially writing the program, but this helped to reduce the number of cache misses and unecessary pointer storage.</li>
<li>Switched from running inside MS Visual Studio to compiling with gcc and running on linux. I didn't do this before because I didn't have a machine running linux with enough memory (and I thought swap files wouldn't handle the load as well as a pagefile had), but when I finally fixed it up to compile in gcc there was a large performance improvement. I figured running in Visual Studio probably hooked memory allocations (or maybe the windows allocator is less suited to this than libc's <code>malloc</code>?), but population times went from minutes to seconds.</li>
<li>I parallelized the table population process. Because data loaded by the table was the output of my own python script, it was easy enough to split the data into multiple chunks that could all be read concurrently (more on this below).</li>
</ul>
<p>Overall, this worked quite well. Some of these changes had drastic effects on memory consumption, which eliminated the need for a pagefile and increased the effects of caching, in turn drastically improving the population time: at the end of the day this step took about five minutes and under 16GB of RAM.</p>
<h3 id="thread-safety">Thread Safety</h3>
<p>For a while, populating the hash table by reading in the output of the python parser was excruciatingly slow. This was mitigated somewhat using many of the memory optimizations above, and I was always planning to sacrifice population time for search time, but I wanted to improve this anyway.</p>
<p>However, parallelizing the table population step seemed unavoidably expensive: assigning a mutex to every element seemed like the safest option but would add an unacceptable amount of overhead, and playing around with atomics hadn't really gone anywhere. Using a single mutex to lock the table would work very poorly because of the number of lookups that were constantly being done: resolving collisions during a table lookup would frequently require several reads (to compare the title stored at an entry to the title being hashed), each of which would require a mutex lock.</p>
<p>Instead of locking the whole table with one mutex or storing a mutex for every slot in the table, there is a middle ground. Instead, there is an array of about <code>m</code> (about 100) mutexes that are tasked with protecting a table of 15 million elements; whenever an index <code>i</code> needs to be read or written, mutex <code>i % m</code> is locked. Because there are so many more entries than mutexes collisions are far from impossible, but the time delay is negligible: at most it's the delay of writing a value to an entry. However, because only 4 threads (or however many cores are being used) will be running at a time, there is a high probability that they will be locking 4 different mutexes, meaning all threads can operate effectively in parallel, with only the overhead of semi-frequent locks/unlocks.</p>
<h3 id="shortcomings">Shortcomings</h3>
<p>The biggest issue with this iteration of the project was data integrity. I had noticed some inconsistencies and what I suspected were longer than necessary paths, from which worries about thread safety arose. Someone recommended that as long as I had this giant table of internal wiki links I should compute the pageranks, but this was difficult or impossible because of redirects.</p>
<p>At the time a search could be choked by using an anomalous page for the destination. For example, the wikipedia page <a href="https://en.wikipedia.org/w/index.php?title=USA&amp;redirect=no">USA</a> redirects to the page for the <a href="https://en.wikipedia.org/wiki/United_States">United States</a>, but that information was not present in the full text dump being given to the python script, so the page table had no way to realize or represent this. A search for &quot;USA&quot; in the destination would search for an article that incorrectly linked to &quot;USA&quot; and relied on the site to handle the redirect. Obviously this was both inefficient and unfaithful to the actual data, but it was a niche case (and kind of a funny one).</p>
<p>The project was functional enough to host, but only for a small group of people. It used <a href="https://github.com/ipkn/crow">crow</a> as a web framework, which was fun to play around with, but wasn't well documented and made it difficult to effectively parallelize the server.</p>
<h2 id="rust-rewrite">Rust rewrite</h2>
<h3 id="why-rust">Why Rust</h3>
<p>I was worried some of the anomalies in searches were the result of a data race, which is what initially pushed me to leave C++ for Rust. I had also seen some interesting crates I wanted to try out (such as <a href="https://crates.io/crates/phf">phf</a>, which I unfortunately had to ditch). But the biggest reason is that Rust is cool, and I like writing it more than C++ (or perhaps more accurately I dislike debugging Rust less than C++).</p>
<h3 id="addressing-shortcomings">Addressing Shortcomings</h3>
<p>Because it was a ground-up rewrite I was free to fix some problems in the C++ version that initially would have required ugly hacks.</p>
<p>One of the biggest differences is how input is handled. Instead of a python script to strip Parent-Child title pairs from the text dump, the Rust version parses article metadata from a series of sql dumps published every month: <code>page.sql</code>, <code>redirects.sql</code>, and <code>pagelinks.sql</code>. Now, instead of mapping article titles to hashes that change every time the program is run, articles are associated with their true <code>page_id</code>, which is simpler and easier to debug (though it means a bit of unnecessary overhead in the form of a table mapping article titles to their <code>page_id</code>). This led to quite a meaningful performance improvement, as it allowed consolidating true links with their redirects and didn't have the shortcoming of including pages linked from the english wiki to another language wiki.</p>
<p>The other major difference is the breadth-first search itself. Rather than only storing child indices and searching until it finds a parent of the destination index, the Rust version stores both children and parent collections; when searching, it populated trees of what unseen nodes are reachable from the source's children/grandchildren/etc. and what unseen nodes are reachable from the destination's parents/grandparents/etc. until the sets intersect. This has the same exponential order notation, but the search depth is effectively halved for a linear cost, which goes a long way.</p>
<h3 id="state-machine-pattern">State Machine Pattern</h3>
<p>One of the biggest purposes this project serves for me is serving as a problem I'm very familiar with that I can use to test out new technologies; it started as an excuse to play around with Visual Studio Community Edition when it came out, as well as hash tables and pagefiles, which I had just learned about, and then evolved to experiments concurrency, then with Rust, then <a href="https://crates.io/crates/phf">phf</a>, and so on.</p>
<p>One of the more recent ideas I wanted to play around with was a <a href="https://hoverbear.org/2016/10/12/rust-state-machine-pattern/">Rust state machine pattern</a>; such state machines utilize Rust's trait system to verify at compile time that they can't be operated upon illegally. Even though the <code>LinkState</code> struct only goes through four sequential states, it's useful that this tool can verify everything is done in the right order. Even though it might be overkill in this situation, it provides yet another data integrity guarantee at compile time and provides a nice structure for organizing the codebase.</p>
<h3 id="pageranks">Pageranks</h3>
<p>After creating a lookup table of articles and their children that took redirects into account, I couldn't not compute the pageranks of the articles. The <a href="https://en.wikipedia.org/wiki/Pagerank">PageRank algorithm</a> was initially used by Google as a metric of centrality of web pages based what pages they link to and the rank of pages that link to them. Each value is between 0 and 1, and can be thought of as the probability that a user who clicks on on links randomly with an 85% chance of clicking again will land on that page. As far as I can tell, the way pagerank is usually computed on very large data sets is with some funky linear algebra that I don't understand, so instead my implementation takes a linear approach. It isn't as fast as it could be, but I was prioritizing makeing the code as straightforward as possible to reduce the possibility of errors. Currently it takes about twelve hours to run on the full English wikipedia (~5 million entries, ~80 links each) with a maximum error of 0.00000001, but that figure was probably exacerbated by the fact that the process was using required swap space (and of course the process only has to be run once per monthly dump).</p>
<p>Currently the pagerank data doesn't serve much of a purpose other than being interesting. There is a <code>rank</code> field in the postgres cache database which is currently used to sort suggestions when a search query does not match a page title, but that's pretty unnoticable. I'll probably do some data visualization project with the data or something.</p>
<p>For now a preview of the highest ranks of the simple wikipedia can be found <a href="https://gist.github.com/stensonowen/25df4124c1509a7033c5e1553c404a47">here</a> and of the english wikipedia can be found <a href="https://gist.github.com/stensonowen/d72342cbee65893e03faf46eb77b2adb">here</a>.</p>
<h3 id="future-work">Future Work</h3>
<p>Optimizations:</p>
<ul class="incremental">
<li>Reduce cache misses by inlining parents/children in ?Sized structs</li>
<li>Use faster hashing via bitwise operations</li>
<li>Refactor parsing module</li>
<li>Rewrite perfect hashing crate</li>
<li>Performance profiling</li>
<li>Experiment with Bloom filters in bfs</li>
</ul>
<p>Features:</p>
<ul class="incremental">
<li>Real fuzzy searching</li>
<li>Incorporate pagerank somehow</li>
</ul>
